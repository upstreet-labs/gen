import * as THREE from 'three';
// import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';
import {SceneGenerator} from '../src/generators/scene-generator.js';
import {createImage, editImg} from '../src/clients/ai-client.js';
// import {labelClasses} from '../src/constants/prompts.js';
import materialColors from '../src/constants/material-colors.js';

import styles from '../styles/Gen.module.css';

//

const sceneGenerator = new SceneGenerator();

//

const vqaQueries = [
  `is this birds eye view?`,
  `is the viewer looking up at the sky?`,
  `is the viewer looking up at the ceiling?`,
  `how many feet tall is the viewer?`,
];

//

// Generated by CoffeeScript 1.12.7
// (function() {
  var ColorScheme,
    slice = [].slice;

  ColorScheme = (function() {
    var clone, l, len, ref, typeIsArray, word;

    typeIsArray = Array.isArray || function(value) {
      return {}.toString.call(value) === '[object Array]';
    };

    ColorScheme.SCHEMES = {};

    ref = "mono monochromatic contrast triade tetrade analogic".split(/\s+/);
    for (l = 0, len = ref.length; l < len; l++) {
      word = ref[l];
      ColorScheme.SCHEMES[word] = true;
    }

    ColorScheme.PRESETS = {
      "default": [-1, -1, 1, -0.7, 0.25, 1, 0.5, 1],
      pastel: [0.5, -0.9, 0.5, 0.5, 0.1, 0.9, 0.75, 0.75],
      soft: [0.3, -0.8, 0.3, 0.5, 0.1, 0.9, 0.5, 0.75],
      light: [0.25, 1, 0.5, 0.75, 0.1, 1, 0.5, 1],
      hard: [1, -1, 1, -0.6, 0.1, 1, 0.6, 1],
      pale: [0.1, -0.85, 0.1, 0.5, 0.1, 1, 0.1, 0.75]
    };

    ColorScheme.COLOR_WHEEL = {
      0: [255, 0, 0, 100],
      15: [255, 51, 0, 100],
      30: [255, 102, 0, 100],
      45: [255, 128, 0, 100],
      60: [255, 153, 0, 100],
      75: [255, 178, 0, 100],
      90: [255, 204, 0, 100],
      105: [255, 229, 0, 100],
      120: [255, 255, 0, 100],
      135: [204, 255, 0, 100],
      150: [153, 255, 0, 100],
      165: [51, 255, 0, 100],
      180: [0, 204, 0, 80],
      195: [0, 178, 102, 70],
      210: [0, 153, 153, 60],
      225: [0, 102, 178, 70],
      240: [0, 51, 204, 80],
      255: [25, 25, 178, 70],
      270: [51, 0, 153, 60],
      285: [64, 0, 153, 60],
      300: [102, 0, 153, 60],
      315: [153, 0, 153, 60],
      330: [204, 0, 153, 80],
      345: [229, 0, 102, 90]
    };

    function ColorScheme() {
      var colors, m;
      colors = [];
      for (m = 1; m <= 4; m++) {
        colors.push(new ColorScheme.mutablecolor(60));
      }
      this.col = colors;
      this._scheme = 'mono';
      this._distance = 0.5;
      this._web_safe = false;
      this._add_complement = false;
    }


    /*
    
    colors()
    
    Returns an array of 4, 8, 12 or 16 colors in RRGGBB hexidecimal notation
    (without a leading "#") depending on the color scheme and addComplement
    parameter. For each set of four, the first is usually the most saturated color,
    the second a darkened version, the third a pale version and fourth
    a less-pale version.
    
    For example: With a contrast scheme, "colors()" would return eight colors.
    Indexes 1 and 5 could be background colors, 2 and 6 could be foreground colors.
    
    Trust me, it's much better if you check out the Color Scheme web site, whose
    URL is listed in "Description"
     */

    ColorScheme.prototype.colors = function() {
      var dispatch, h, i, j, m, n, output, ref1, used_colors;
      used_colors = 1;
      h = this.col[0].get_hue();
      dispatch = {
        mono: (function(_this) {
          return function() {};
        })(this),
        contrast: (function(_this) {
          return function() {
            used_colors = 2;
            _this.col[1].set_hue(h);
            return _this.col[1].rotate(180);
          };
        })(this),
        triade: (function(_this) {
          return function() {
            var dif;
            used_colors = 3;
            dif = 60 * _this._distance;
            _this.col[1].set_hue(h);
            _this.col[1].rotate(180 - dif);
            _this.col[2].set_hue(h);
            return _this.col[2].rotate(180 + dif);
          };
        })(this),
        tetrade: (function(_this) {
          return function() {
            var dif;
            used_colors = 4;
            dif = 90 * _this._distance;
            _this.col[1].set_hue(h);
            _this.col[1].rotate(180);
            _this.col[2].set_hue(h);
            _this.col[2].rotate(180 + dif);
            _this.col[3].set_hue(h);
            return _this.col[3].rotate(dif);
          };
        })(this),
        analogic: (function(_this) {
          return function() {
            var dif;
            used_colors = _this._add_complement ? 4 : 3;
            dif = 60 * _this._distance;
            _this.col[1].set_hue(h);
            _this.col[1].rotate(dif);
            _this.col[2].set_hue(h);
            _this.col[2].rotate(360 - dif);
            _this.col[3].set_hue(h);
            return _this.col[3].rotate(180);
          };
        })(this)
      };
      dispatch['monochromatic'] = dispatch['mono'];
      if (dispatch[this._scheme] != null) {
        dispatch[this._scheme]();
      } else {
        throw "Unknown color scheme name: " + this._scheme;
      }
      output = [];
      for (i = m = 0, ref1 = used_colors - 1; 0 <= ref1 ? m <= ref1 : m >= ref1; i = 0 <= ref1 ? ++m : --m) {
        for (j = n = 0; n <= 3; j = ++n) {
          output[i * 4 + j] = this.col[i].get_hex(this._web_safe, j);
        }
      }
      return output;
    };


    /*
    
    colorset()
    
    Returns a list of lists of the colors in groups of four. This method simply
    allows you to reference a color in the scheme by its group isntead of its
    absolute index in the list of colors.  I am assuming that "colorset()"
    will make it easier to use this module with the templating systems that are
    out there.
    
    For example, if you were to follow the synopsis, say you wanted to retrieve
    the two darkest colors from the first two groups of the scheme, which is
    typically the second color in the group. You could retrieve them with
    "colors()"
    
        first_background  = (scheme.colors())[1];
        second_background = (scheme.colors())[5];
    
    Or, with this method,
    
        first_background  = (scheme.colorset())[0][1]
        second_background = (scheme.colorset())[1][1]
     */

    ColorScheme.prototype.colorset = function() {
      var flat_colors, grouped_colors;
      flat_colors = clone(this.colors());
      grouped_colors = [];
      while (flat_colors.length > 0) {
        grouped_colors.push(flat_colors.splice(0, 4));
      }
      return grouped_colors;
    };


    /*
    
    from_hue( degrees )
    
    Sets the base color hue, where 'degrees' is an integer. (Values greater than
    359 and less than 0 wrap back around the wheel.)
    
    The default base hue is 0, or bright red.
     */

    ColorScheme.prototype.from_hue = function(h) {
      if (h == null) {
        throw "from_hue needs an argument";
      }
      this.col[0].set_hue(h);
      return this;
    };

    ColorScheme.prototype.rgb2ryb = function() {
      var blue, green, iN, maxgreen, maxyellow, red, rgb, white, yellow;
      rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((rgb[0] != null) && typeIsArray(rgb[0])) {
        rgb = rgb[0];
      }
      red = rgb[0], green = rgb[1], blue = rgb[2];
      white = Math.min(red, green, blue);
      red -= white;
      green -= white;
      blue -= white;
      maxgreen = Math.max(red, green, blue);
      yellow = Math.min(red, green);
      red -= yellow;
      green -= yellow;
      if (blue > 0 && green > 0) {
        blue /= 2;
        green /= 2;
      }
      yellow += green;
      blue += green;
      maxyellow = Math.max(red, yellow, blue);
      if (maxyellow > 0) {
        iN = maxgreen / maxyellow;
        red *= iN;
        yellow *= iN;
        blue *= iN;
      }
      red += white;
      yellow += white;
      blue += white;
      return [Math.floor(red), Math.floor(yellow), Math.floor(blue)];
    };

    ColorScheme.prototype.rgb2hsv = function() {
      var b, d, g, h, max, min, r, rgb, s, v;
      rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((rgb[0] != null) && typeIsArray(rgb[0])) {
        rgb = rgb[0];
      }
      r = rgb[0], g = rgb[1], b = rgb[2];
      r /= 255;
      g /= 255;
      b /= 255;
      min = Math.min.apply(Math, [r, g, b]);
      max = Math.max.apply(Math, [r, g, b]);
      d = max - min;
      v = max;
      s;
      if (d > 0) {
        s = d / max;
      } else {
        return [0, 0, v];
      }
      h = (r === max ? (g - b) / d : (g === max ? 2 + (b - r) / d : 4 + (r - g) / d));
      h *= 60;
      h %= 360;
      return [h, s, v];
    };

    ColorScheme.prototype.rgbToHsv = function() {
      var b, d, g, h, max, min, r, rgb, s, v;
      rgb = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      if ((rgb[0] != null) && typeIsArray(rgb[0])) {
        rgb = rgb[0];
      }
      r = rgb[0], g = rgb[1], b = rgb[2];
      r /= 255;
      g /= 255;
      b /= 255;
      max = Math.max(r, g, b);
      min = Math.min(r, g, b);
      h = void 0;
      s = void 0;
      v = max;
      d = max - min;
      s = max === 0 ? 0 : d / max;
      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            h = (g - b) / d + (g < b ? 6 : 0);
            break;
          case g:
            h = (b - r) / d + 2;
            break;
          case b:
            h = (r - g) / d + 4;
        }
        h /= 6;
      }
      return [h, s, v];
    };


    /*
    
    from_hex( color )
    
    Sets the base color to the given color, where 'color' is in the hexidecimal
    form RRGGBB. 'color' should not be preceded with a hash (#).
    
    The default base color is the equivalent of #ff0000, or bright red.
     */

    ColorScheme.prototype.from_hex = function(hex) {
      var b, g, h, h0, h1, h2, hsv, i1, i2, num, r, ref1, ref2, rgbcap, s, v;
      if (hex == null) {
        throw "from_hex needs an argument";
      }
      if (!/^([0-9A-F]{2}){3}$/im.test(hex)) {
        throw "from_hex(" + hex + ") - argument must be in the form of RRGGBB";
      }
      rgbcap = /(..)(..)(..)/.exec(hex).slice(1, 4);
      ref1 = (function() {
        var len1, m, results;
        results = [];
        for (m = 0, len1 = rgbcap.length; m < len1; m++) {
          num = rgbcap[m];
          results.push(parseInt(num, 16));
        }
        return results;
      })(), r = ref1[0], g = ref1[1], b = ref1[2];
      ref2 = this.rgb2ryb([r, g, b]), r = ref2[0], g = ref2[1], b = ref2[2];
      hsv = this.rgbToHsv(r, g, b);
      h0 = hsv[0];
      h1 = 0;
      h2 = 1000;
      i1 = null;
      i2 = null;
      h = null;
      s = null;
      v = null;
      h = hsv[0];
      s = hsv[1];
      v = hsv[2];
      this.from_hue(h * 360);
      this._set_variant_preset([s, v, s, v * 0.7, s * 0.25, 1, s * 0.5, 1]);
      return this;
    };


    /*
    
    add_complement( BOOLEAN )
    
    If BOOLEAN is true, an extra set of colors will be produced using the
    complement of the selected color.
    
    This only works with the analogic color scheme. The default is false.
     */

    ColorScheme.prototype.add_complement = function(b) {
      if (b == null) {
        throw "add_complement needs an argument";
      }
      this._add_complement = b;
      return this;
    };


    /*
    
    web_safe( BOOL )
    
    Sets whether the colors returned by L<"colors()"> or L<"colorset()"> will be
    web-safe.
    
    The default is false.
     */

    ColorScheme.prototype.web_safe = function(b) {
      if (b == null) {
        throw "web_safe needs an argument";
      }
      this._web_safe = b;
      return this;
    };


    /*
    
    distance( FLOAT )
    
    'FLOAT'> must be a value from 0 to 1. You might use this with the "triade"
    "tetrade" or "analogic" color schemes.
    
    The default is 0.5.
     */

    ColorScheme.prototype.distance = function(d) {
      if (d == null) {
        throw "distance needs an argument";
      }
      if (d < 0) {
        throw "distance(" + d + ") - argument must be >= 0";
      }
      if (d > 1) {
        throw "distance(" + d + ") - argument must be <= 1";
      }
      this._distance = d;
      return this;
    };


    /*
    
    scheme( name )
    
    'name' must be a valid color scheme name. See "Color Schemes". The default
    is "mono"
     */

    ColorScheme.prototype.scheme = function(name) {
      if (name == null) {
        return this._scheme;
      } else {
        if (ColorScheme.SCHEMES[name] == null) {
          throw "'" + name + "' isn't a valid scheme name";
        }
        this._scheme = name;
        return this;
      }
    };


    /*
    
    variation( name )
    
    'name' must be a valid color variation name. See "Color Variations"
     */

    ColorScheme.prototype.variation = function(v) {
      if (v == null) {
        throw "variation needs an argument";
      }
      if (ColorScheme.PRESETS[v] == null) {
        throw "'$v' isn't a valid variation name";
      }
      this._set_variant_preset(ColorScheme.PRESETS[v]);
      return this;
    };

    ColorScheme.prototype._set_variant_preset = function(p) {
      var i, m, results;
      results = [];
      for (i = m = 0; m <= 3; i = ++m) {
        results.push(this.col[i].set_variant_preset(p));
      }
      return results;
    };

    clone = function(obj) {
      var flags, key, newInstance;
      if ((obj == null) || typeof obj !== 'object') {
        return obj;
      }
      if (obj instanceof Date) {
        return new Date(obj.getTime());
      }
      if (obj instanceof RegExp) {
        flags = '';
        if (obj.global != null) {
          flags += 'g';
        }
        if (obj.ignoreCase != null) {
          flags += 'i';
        }
        if (obj.multiline != null) {
          flags += 'm';
        }
        if (obj.sticky != null) {
          flags += 'y';
        }
        return new RegExp(obj.source, flags);
      }
      newInstance = new obj.constructor();
      for (key in obj) {
        newInstance[key] = clone(obj[key]);
      }
      return newInstance;
    };

    ColorScheme.mutablecolor = (function() {
      mutablecolor.prototype.hue = 0;

      mutablecolor.prototype.saturation = [];

      mutablecolor.prototype.value = [];

      mutablecolor.prototype.base_red = 0;

      mutablecolor.prototype.base_green = 0;

      mutablecolor.prototype.base_saturation = 0;

      mutablecolor.prototype.base_value = 0;

      function mutablecolor(hue) {
        if (hue == null) {
          throw "No hue specified";
        }
        this.saturation = [];
        this.value = [];
        this.base_red = 0;
        this.base_green = 0;
        this.base_blue = 0;
        this.base_saturation = 0;
        this.base_value = 0;
        this.set_hue(hue);
        this.set_variant_preset(ColorScheme.PRESETS['default']);
      }

      mutablecolor.prototype.get_hue = function() {
        return this.hue;
      };

      mutablecolor.prototype.set_hue = function(h) {
        var avrg, color, colorset1, colorset2, d, derivative1, derivative2, en, i, k;
        avrg = function(a, b, k) {
          return a + Math.round((b - a) * k);
        };
        this.hue = Math.round(h % 360);
        d = this.hue % 15 + (this.hue - Math.floor(this.hue));
        k = d / 15;
        derivative1 = this.hue - Math.floor(d);
        derivative2 = (derivative1 + 15) % 360;
        if (derivative1 === 360) {
          derivative1 = 0;
        }
        if (derivative2 === 360) {
          derivative2 = 0;
        }
        colorset1 = ColorScheme.COLOR_WHEEL[derivative1];
        colorset2 = ColorScheme.COLOR_WHEEL[derivative2];
        en = {
          red: 0,
          green: 1,
          blue: 2,
          value: 3
        };
        for (color in en) {
          i = en[color];
          this["base_" + color] = avrg(colorset1[i], colorset2[i], k);
        }
        this.base_saturation = avrg(100, 100, k) / 100;
        return this.base_value /= 100;
      };

      mutablecolor.prototype.rotate = function(angle) {
        var newhue;
        newhue = (this.hue + angle) % 360;
        return this.set_hue(newhue);
      };

      mutablecolor.prototype.get_saturation = function(variation) {
        var s, x;
        x = this.saturation[variation];
        s = x < 0 ? -x * this.base_saturation : x;
        if (s > 1) {
          s = 1;
        }
        if (s < 0) {
          s = 0;
        }
        return s;
      };

      mutablecolor.prototype.get_value = function(variation) {
        var v, x;
        x = this.value[variation];
        v = x < 0 ? -x * this.base_value : x;
        if (v > 1) {
          v = 1;
        }
        if (v < 0) {
          v = 0;
        }
        return v;
      };

      mutablecolor.prototype.set_variant = function(variation, s, v) {
        this.saturation[variation] = s;
        return this.value[variation] = v;
      };

      mutablecolor.prototype.set_variant_preset = function(p) {
        var i, m, results;
        results = [];
        for (i = m = 0; m <= 3; i = ++m) {
          results.push(this.set_variant(i, p[2 * i], p[2 * i + 1]));
        }
        return results;
      };

      mutablecolor.prototype.get_hex = function(web_safe, variation) {
        var c, color, formatted, i, k, len1, len2, m, max, min, n, ref1, rgb, rgbVal, s, str, v;
        max = Math.max.apply(Math, (function() {
          var len1, m, ref1, results;
          ref1 = ['red', 'green', 'blue'];
          results = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            color = ref1[m];
            results.push(this["base_" + color]);
          }
          return results;
        }).call(this));
        min = Math.min.apply(Math, (function() {
          var len1, m, ref1, results;
          ref1 = ['red', 'green', 'blue'];
          results = [];
          for (m = 0, len1 = ref1.length; m < len1; m++) {
            color = ref1[m];
            results.push(this["base_" + color]);
          }
          return results;
        }).call(this));
        v = (variation < 0 ? this.base_value : this.get_value(variation)) * 255;
        s = variation < 0 ? this.base_saturation : this.get_saturation(variation);
        k = max > 0 ? v / max : 0;
        rgb = [];
        ref1 = ['red', 'green', 'blue'];
        for (m = 0, len1 = ref1.length; m < len1; m++) {
          color = ref1[m];
          rgbVal = Math.min.apply(Math, [255, Math.round(v - (v - this["base_" + color] * k) * s)]);
          rgb.push(rgbVal);
        }
        if (web_safe) {
          rgb = (function() {
            var len2, n, results;
            results = [];
            for (n = 0, len2 = rgb.length; n < len2; n++) {
              c = rgb[n];
              results.push(Math.round(c / 51) * 51);
            }
            return results;
          })();
        }
        formatted = "";
        for (n = 0, len2 = rgb.length; n < len2; n++) {
          i = rgb[n];
          str = i.toString(16);
          if (str.length < 2) {
            str = "0" + str;
          }
          formatted += str;
        }
        return formatted;
      };

      return mutablecolor;

    })();

    return ColorScheme;

  })();

//

const createSeedImage = (
  w, // width
  h, // height
  rw, // radius width
  rh, // radius height
  p, // power distribution of radius
  n, // number of rectangles
  shape, // 'ellipse' or 'rectangle'
  {
    color = null,
    monochrome = false,
    // blur = 0,
  } = {},
) => {
  const rng = () => (Math.random() * 2) - 1;
  const baseColors = Object.keys(materialColors).map(k => materialColors[k][400].slice(1));

  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, w, h);

  const maskCanvas = document.createElement('canvas');
  maskCanvas.width = w;
  maskCanvas.height = h;
  const maskCtx = maskCanvas.getContext('2d');
  maskCtx.fillStyle = '#fff';
  maskCtx.fillRect(0, 0, w, h);

  const baseColor = color ?? baseColors[Math.floor(Math.random() * baseColors.length)];
  const scheme = new ColorScheme();
  scheme.from_hex(baseColor)
    .scheme(monochrome ? 'mono' : 'triade')   
    // .variation('hard');
  const colors = scheme.colors();

  for (let i = 0; i < n; i++) {
    const x = w / 2 + rng() * rw;
    const y = h / 2 + rng() * rh;
    const sw = Math.pow(Math.random(), p) * rw;
    const sh = Math.pow(Math.random(), p) * rh;
    ctx.fillStyle = '#' + colors[Math.floor(Math.random() * colors.length)];
    if (shape === 'ellipse') {
      ctx.beginPath();
      ctx.ellipse(x, y, sw, sh, 0, 0, 2 * Math.PI);
      ctx.fill();
    } else {
      ctx.fillRect(x - sw / 2, y - sh / 2, sw, sh);
    }
  }

  // make this box transparent in the mask
  // requires blend mode
  maskCtx.fillStyle = 'rgba(255, 255, 255, 1)';
  maskCtx.globalCompositeOperation = 'destination-out';
  if (shape === 'ellipse') {
    maskCtx.beginPath();
    maskCtx.ellipse(w / 2, h / 2, w / 2 * 0.9, h / 2 * 0.9, 0, 0, 2 * Math.PI);
    maskCtx.fill();
  } else if (shape === 'rectangle') {
    const innerRatio = 0.1;
    maskCtx.fillRect(w * innerRatio, 0, w - w * innerRatio * 2, h);
  }

  return {
    canvas,
    maskCanvas,
  };
};
const makeCharacterSeedImage = () => {
  return createSeedImage(512, 512, 64, 128, 1, 256);
};
globalThis.makeCharacterSeedImage = makeCharacterSeedImage;
const createFullSeedImage = () => {
  const rng = () => (Math.random() * 2) - 1;
  const baseColors = Object.keys(materialColors).map(k => materialColors[k][400].slice(1));

  const canvas = document.createElement('canvas');
  canvas.width = w;
  canvas.height = h;

  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#fff';
  ctx.fillRect(0, 0, w, h);
  // ctx.filter = blur ? `blur(${blur}px) saturate(1.5)` : '';

  const minSize = 64;
  
  const baseColor = color ?? baseColors[Math.floor(Math.random() * baseColors.length)];
  const scheme = new ColorScheme();
  scheme.from_hex(baseColor)
    .scheme(monochrome ? 'mono' : 'triade')   
    // .variation('hard');
  const colors = scheme.colors();

  for (let i = 0; i < n; i++) {
    const x = w / 2 + rng() * rw;
    const y = h / 2 + rng() * rh;
    const sw = Math.pow(Math.random(), p) * rw;
    const sh = Math.pow(Math.random(), p) * rh;
    ctx.fillStyle = '#' + colors[Math.floor(Math.random() * colors.length)];

    ctx.fillRect(x - sw / 2, y - sh / 2, sw, sh);
  }

  return canvas;
};
globalThis.createFullSeedImage = createFullSeedImage;

// 

function pDistance(x, y, x1, y1, x2, y2) {
  var A = x - x1;
  var B = y - y1;
  var C = x2 - x1;
  var D = y2 - y1;

  var dot = A * C + B * D;
  var len_sq = C * C + D * D;
  var param = -1;
  if (len_sq != 0) //in case of 0 length line
      param = dot / len_sq;

  var xx, yy;

  if (param < 0) {
    xx = x1;
    yy = y1;
  }
  else if (param > 1) {
    xx = x2;
    yy = y2;
  }
  else {
    xx = x1 + param * C;
    yy = y1 + param * D;
  }

  var dx = x - xx;
  var dy = y - yy;
  return Math.sqrt(dx * dx + dy * dy);
}
function distanceToLine(p, line) {
  return pDistance(p[0], p[1], line[0][0], line[0][1], line[1][0], line[1][1]);
}
function getLineForViewport(viewport) {
  const w = viewport[2] - viewport[0];
  const h = viewport[3] - viewport[1];
  const r = Math.min(w, h) / 2;
  return [
    [
      viewport[0] + r,
      viewport[1] + r,
    ],
    [
      viewport[2] - r,
      viewport[3] - r,
    ],
  ];
}

//

/* const convertToUint16 = (() => {
  const tmpArray = new Uint16Array(1);
  return v => {
    tmpArray[0] = v;
    return tmpArray[0];
  };
})(); */

//

const calcSDF = (() => {
  var INF = 1e20

  function calcSDF(src, options) {
      if (!options) options = {}

      var cutoff = options.cutoff == null ? 0.25 : options.cutoff
      var radius = options.radius == null ? 8 : options.radius
      var channel = options.channel || 0
      var w, h, size, data, intData, stride, ctx, canvas, imgData, i, l

      // handle image container
      if (ArrayBuffer.isView(src) || Array.isArray(src)) {
          if (!options.width || !options.height) throw Error('For raw data width and height should be provided by options')
          w = options.width, h = options.height
          data = src

          if (!options.stride) stride = Math.floor(src.length / w / h)
          else stride = options.stride
      }
      else {
          if (window.HTMLCanvasElement && src instanceof window.HTMLCanvasElement) {
              canvas = src
              ctx = canvas.getContext('2d')
              w = canvas.width, h = canvas.height
              imgData = ctx.getImageData(0, 0, w, h)
              data = imgData.data
              stride = 4
          }
          else if (window.CanvasRenderingContext2D && src instanceof window.CanvasRenderingContext2D) {
              canvas = src.canvas
              ctx = src
              w = canvas.width, h = canvas.height
              imgData = ctx.getImageData(0, 0, w, h)
              data = imgData.data
              stride = 4
          }
          else if (window.ImageData && src instanceof window.ImageData) {
              imgData = src
              w = src.width, h = src.height
              data = imgData.data
              stride = 4
          }
      }

      size = Math.max(w, h)

      //convert int data to floats
      if ((window.Uint8ClampedArray && data instanceof window.Uint8ClampedArray) || (window.Uint8Array && data instanceof window.Uint8Array)) {
          intData = data
          data = Array(w*h)

          for (i = 0, l = Math.floor(intData.length / stride); i < l; i++) {
              data[i] = intData[i*stride + channel] / 255
          }
      }
      else {
          if (stride !== 1) throw Error('Raw data can have only 1 value per pixel')
      }

      // temporary arrays for the distance transform
      var gridOuter = Array(w * h)
      var gridInner = Array(w * h)
      var f = Array(size)
      var d = Array(size)
      var z = Array(size + 1)
      var v = Array(size)

      for (i = 0, l = w * h; i < l; i++) {
          var a = data[i]
          gridOuter[i] = a === 1 ? 0 : a === 0 ? INF : Math.pow(Math.max(0, 0.5 - a), 2)
          gridInner[i] = a === 1 ? INF : a === 0 ? 0 : Math.pow(Math.max(0, a - 0.5), 2)
      }

      edt(gridOuter, w, h, f, d, v, z)
      edt(gridInner, w, h, f, d, v, z)

      var dist = window.Float32Array ? new Float32Array(w * h) : new Array(w * h)

      for (i = 0, l = w*h; i < l; i++) {
          dist[i] = Math.min(Math.max(1 - ( (gridOuter[i] - gridInner[i]) / radius + cutoff), 0), 1)
      }

      return dist
  }

  // 2D Euclidean distance transform by Felzenszwalb & Huttenlocher https://cs.brown.edu/~pff/dt/
  function edt(data, width, height, f, d, v, z) {
      for (var x = 0; x < width; x++) {
          for (var y = 0; y < height; y++) {
              f[y] = data[y * width + x]
          }
          edt1d(f, d, v, z, height)
          for (y = 0; y < height; y++) {
              data[y * width + x] = d[y]
          }
      }
      for (y = 0; y < height; y++) {
          for (x = 0; x < width; x++) {
              f[x] = data[y * width + x]
          }
          edt1d(f, d, v, z, width)
          for (x = 0; x < width; x++) {
              data[y * width + x] = Math.sqrt(d[x])
          }
      }
  }

  // 1D squared distance transform
  function edt1d(f, d, v, z, n) {
      v[0] = 0;
      z[0] = -INF
      z[1] = +INF

      for (var q = 1, k = 0; q < n; q++) {
          var s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k])
          while (s <= z[k]) {
              k--
              s = ((f[q] + q * q) - (f[v[k]] + v[k] * v[k])) / (2 * q - 2 * v[k])
          }
          k++
          v[k] = q
          z[k] = s
          z[k + 1] = +INF
      }

      for (q = 0, k = 0; q < n; q++) {
          while (z[k + 1] < q) k++
          d[q] = (q - v[k]) * (q - v[k]) + f[v[k]]
      }
  }
  
  return calcSDF;
})();

//

const getFormData = o => {
  const formData = new FormData();
  for (const k in o) {
    formData.append(k, o[k]);
  }
  return formData;
};

//

globalThis.testPotionSeed = async () => {
  const {
    canvas,
    maskCanvas,
  } = createSeedImage(
    512, // w
    512, // h
    100, // rw
    100, // rh
    1, // p
    256, // n
    'rectangle', // shape
  );

  canvas.classList.add('mainCanvas');
  canvas.style.cssText = `\
    background: red;
  `;
  document.body.appendChild(canvas);
  maskCanvas.classList.add('maskCanvas');
  maskCanvas.style.cssText = `\
    background: red;
  `;
  document.body.appendChild(maskCanvas);

  const blob = await new Promise((accept, reject) => {
    canvas.toBlob(accept, 'image/png');
  });
  const maskBlob = await new Promise((accept, reject) => {
    maskCanvas.toBlob(accept, 'image/png');
  });
  // const prompt = `magical alien grass blades on a white background, studio ghibli anime style, digital art`;
  // const prompt = `ancient magical cloudy potion antigravity on a white background, studio ghibli anime style, digital art`;
  // const prompt = `high tech energy sword with hexagon pattern and mysterious glyphs on it, white background, video game item concept art render, trending on ArtStation, digital art`;
  // const prompt = `juicy magical alien fruit, anime style, white background, digital art`;`
  // const prompt = `huge square sword, anime style, rendered in unreal engine, white background, digital art`;
  // const prompt = `cute little anime ghost pet with tiny legs on a white background, studio ghibli, digital art`;
  // const prompt = `strange alien plant with flowers on a white background, studio ghibli anime style, digital art`;
  // const prompt = `ancient high tech medkit on a white background, studio ghibli anime style, digital art`;
  // const prompt = `ancient magical high tech book with digital symbols on it on a white background, studio ghibli anime style, digital art`;
  const prompt = `ancient magical cloudy potion of terrible death soul on a white background, studio ghibli anime style, digital art`;

  const img = await createImage(prompt);
  document.body.appendChild(img);

  const pixelSize = 64;
  const pixelCanvas = document.createElement('canvas');
  pixelCanvas.width = pixelSize;
  pixelCanvas.height = pixelSize;
  const pixelContext = pixelCanvas.getContext('2d');
  pixelContext.imageSmoothingEnabled = false;
  pixelContext.drawImage(img, 0, 0, pixelSize, pixelSize);
  document.body.appendChild(pixelCanvas);
};

//

// spec is like [[0, 1], [2, 3]]
const outpaintImage = async (img, prompt, specs) => {
  const w = img.width;
  const h = img.height;

  // prepare global canvas
  let canvasBounds = null;
  for (let i = 0; i < specs.length; i++) {
    const [dx, dy] = specs[i];
    if (!canvasBounds) {
      canvasBounds = [
        dx * img.width,
        dy * img.width,
        dx * img.width + img.width,
        dy * img.height + img.height,
      ];
    } else {
      canvasBounds[0] = Math.min(canvasBounds[0], dx * img.width);
      canvasBounds[1] = Math.min(canvasBounds[1], dy * img.height);
      canvasBounds[2] = Math.max(canvasBounds[2], dx * img.width + img.width);
      canvasBounds[3] = Math.max(canvasBounds[3], dy * img.height + img.height);
    }
  }
  // create global canvas
  const globalCanvas = document.createElement('canvas');
  globalCanvas.width = canvasBounds[2] - canvasBounds[0];
  globalCanvas.height = canvasBounds[3] - canvasBounds[1];
  globalCanvas.classList.add('globalCanvas');
  const globalCtx = globalCanvas.getContext('2d');
  // draw the base image in the center
  globalCtx.drawImage(img, -canvasBounds[0], -canvasBounds[1]);

  // outpaint all specs in parallel
  await Promise.all(specs.map(async (spec, i) => {
    const [dx, dy] = spec;

    const canvas = document.createElement('canvas');
    if (!canvas.classList) {
      debugger;
    }
    canvas.classList.add('canvas-' + i);
    canvas.width = w;
    canvas.height = h;
    canvas.style.cssText = `\
      background: red;
    `;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#FFF';
    ctx.fillRect(0, 0, w, h);
    document.body.appendChild(canvas);

    const maskCanvas = document.createElement('canvas');
    // if (!maskCanvas.classList) {
    //   debugger;
    // }
    maskCanvas.classList.add('maskCanvas-' + i);
    maskCanvas.width = w;
    maskCanvas.height = h;
    maskCanvas.style.cssText = `\
      background: red;
    `;
    const maskCtx = maskCanvas.getContext('2d');
    maskCtx.fillStyle = '#FFF';
    maskCtx.fillRect(0, 0, w, h);
    document.body.appendChild(maskCanvas);

    // draw the offsetted canvas
    ctx.drawImage(img, -dx * w, -dy * h);
    maskCtx.fillStyle = 'rgba(255, 255, 255, 1)';
    maskCtx.globalCompositeOperation = 'destination-out';
    maskCtx.fillRect(dx * w, dy * h, w, h);

    const blob = await new Promise((accept, reject) => {
      canvas.toBlob(accept, 'image/png');
    });
    const maskBlob = await new Promise((accept, reject) => {
      maskCanvas.toBlob(accept, 'image/png');
    });

    // fetch from openai
    const editedImg = await editImg(blob, maskBlob, prompt);
    // console.log('got edited img', editedImg);
    if (!editedImg.classList) {
      debugger;
    }
    editedImg.classList.add('editImg-' + i);
    document.body.appendChild(editedImg);

    // draw back to the global canvas
    globalCtx.drawImage(editedImg, dx * w - canvasBounds[0], dy * h - canvasBounds[1]);
  }));

  // console.log('return global canvas', globalCanvas);

  return globalCanvas;
};
globalThis.testCharacterSeed = async () => {
  /* const {
    canvas,
    maskCanvas,
  } = createSeedImage(
    512, // w
    512, // h
    128, // rw
    128, // rh
    1, // p
    256, // n
    'rectangle',
  );

  canvas.classList.add('mainCanvas');
  canvas.style.cssText = `\
    background: red;
  `;
  document.body.appendChild(canvas);
  maskCanvas.classList.add('maskCanvas');
  maskCanvas.style.cssText = `\
    background: red;
  `;
  document.body.appendChild(maskCanvas);

  const blob = await new Promise((accept, reject) => {
    canvas.toBlob(accept, 'image/png');
  });
  const maskBlob = await new Promise((accept, reject) => {
    maskCanvas.toBlob(accept, 'image/png');
  });
  const prompt = prompts.character;

  const fd = getFormData({
    image: blob,
    mask: maskBlob,
    prompt,
    n: 1,
    size: '1024x1024',
  });
  const response = await fetch(`https://api.openai.com/v1/images/edits`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${OPENAI_API_KEY}`,
    },
    body: fd,
  });
  const responseData = await response.json();
  console.log('response data 1', responseData);
  let image_url = responseData.data[0].url;
  console.log('response data 2', image_url);

  const u2 = new URL('/api/proxy', location.href);
  u2.searchParams.set('url', image_url);
  image_url = u2.href; */

  const prompt = prompts.character;
  const response = await createImage(prompt);
  document.body.appendChild(img);

  const outpaintedCanvas = await outpaintImage(img, prompt, [
    [0, -0.5],
    [0, 0.5],
  ]);
  console.log('done outpainting', outpaintedCanvas);
  document.body.appendChild(outpaintedCanvas);
};

//

const Gen = () => {
  // const [minMax, setMinMax] = useState([0, 0, 0, 0]);
  
  return (
    <div className={styles.gen}>
      <div className={styles.tabs}>
        <div className={styles.tab} onClick={async () => {
          await sceneGenerator.generate();
        }}>Scene</div>
      </div>
    </div>
  );
};
export default Gen;